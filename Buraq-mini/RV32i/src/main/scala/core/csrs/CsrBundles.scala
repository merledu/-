package main.scala.core.csrs
import chisel3._
import chisel3.experimental.ChiselEnum

// interrupt requests
// three type of interrupts are supported by this version of BURAQ-MINI.
// 1) softeware interrupts
// 2) timer interupts
// 3) external interrupts
// external interrupts are generated by all external device in curent implementation
// there are two main external interrupt sources.
// 1) GPIOs
// 2) UART
// and NMI at highest prioritySave
class irqs_t extends Bundle{
  // the wires declared here are in reverse order.
  // Generally according to the structure of the MIE register,  _____________________
  //                                                           | MEIE | MTIE | MSIE |
  //                                                            --------------------
  // the irq_software should come first,
  // the irq_timer should come second,
  // the irq_external should come last
  // BUT, the asTypeOf(new irqs_t()) inverts this order (VERIFIED ON SCASTIE)
  // i.e  if this bundle is given value 1.U,
  // the LSB bit would be given to the last wire declared in this bundle
  // this causes writing 1.U to the MSIE for enabling irq_software,
  // to actually enable irq_external MEIE since it would be the last declared wire
  // which would be wrong functionality, hence changing the order of the bundle
  val irq_external        = Bool()
  val irq_timer           = Bool()
  val irq_software        = Bool()
}

// csr operations
// 4 type of operations are performed on csrs
// 1) Read: simple read operation e.g, reading "minstret" csr to check the no:of instructions executed
// 2) Write: simple write operation e.g, writing to "mtimecmp" csr to set a timer event.
// 3) Set: setting particular bits of the csrs e.g, writing to the "mstatus.mie" to enable interrupts globaly
// 4) Clear: clearing particular bits of csrs.
class csr_op_e extends Bundle{
  val CSR_OP_READ        = "b00"
  val CSR_OP_WRITE       = "b01"
  val CSR_OP_SET         = "b10"
  val CSR_OP_CLEAR       = "b11"
}

// bit fields of mstatus register
// 1) mie: machine interrupt enable used to enable interrupts globally
// 2) mpie:machine pervious interrupt enable. whenever a trap is encountered
// the mpie field will be written with the value of mie and mie will be cleared
// 3) mpp: machine privious priv 2 bit wide because we have 4 priv-levels
// 4) mprv: memory privilege field used to modify priv-level at which loads and stores executes
// usually used when memory protection is enabled or in secure embbeded enviornment.
// 5) tw: time out wait supports intercepting the WFI(wait for interrupt) instruction

class status_t extends Bundle{
  // the wires declared here are in reverse order.
  // Generally according to the structure of the MSTATUS register,
  //
  // ________________________________
  // | TW | MPRV | MPP | MPIE | MIE |
  // --------------------------------
  //
  // the mie should come first,
  // the mpie should come second,
  // the mpp should come third,
  // the mprv should come fourth,
  // the tw should come fifth,

  // BUT, the asTypeOf(new mstatus_t()) inverts this order (VERIFIED ON SCASTIE)
  // i.e  if this bundle is given value 1.U,
  // the LSB bit would be given to the last wire declared in this bundle
  // this causes writing 1.U to the MIE for enabling global interrupts,
  // to actually enable timeout wait TW since it would be the last declared wire
  // which would be wrong functionality, hence changing the order of the bundle
  // BEFORE
  //  val mie        = Bool()
  //  val mpie       = Bool()
  //  val mpp        = UInt(2.W)
  //  val mprv       = Bool()
  //  val tw         = Bool()
  // NOW
  val tw = Bool()
  val mprv = Bool()
  val mpp = UInt(2.W)
  val mpie = Bool()
  val mie = Bool()

}

// bit fields of "dcsr"
// TODO: description to be provided after studying debug spec.
class dcsr_t extends Bundle{
  val xdebugver        = UInt(4.W)
  val zero2            = UInt(12.W)
  val ebreakm          = Bool()
  val zero1            = Bool()
  val ebreaks          = Bool()
  val stepie           = Bool()
  val stopcount        = Bool()
  val stoptime         = Bool()
  val cause            = Bool()
  val zero0            = Bool()
  val mprven           = Bool()
  val nmip             = Bool()
  val step             = Bool()
  val prv              = Bool()
}

// all supported privilege levels supported by RISCV along with their specific codes.
// current implementation only supports M-mode
// which is the highest privilege mode if debug unit is not implemented.
// these codes are also stored in mstatus.mpp and mstatus.hpp
// to indicate the privous priv-level when handling an interrupt or exception
// in particular priv-mode e.g, an interrupt is needed to be handled in MACHINE mode
// but curent execution mode.
object priv_lvl_e extends ChiselEnum{
  val PRIV_LVL_U, PRIV_LVL_S, PRIV_LVL_H, PRIV_LVL_M = Value
}

// field specific to debug unit
// TODO: description will be added after studying debug spec
object x_debug_ver_e extends ChiselEnum{
  val XDEBUGVER_NO, zero1, zero2, zero3,XDEBUGVER_STD,
  zero4, zero5, zero6, zero7, zero8, zero9, zero10,
  zero11, zero12,zero13, XDEBUGVER_NONSTD = Value // no external debug support
  //   val XDEBUGVER_STD           = 4 // external debug according to RISC-V debug spec
  //   val XDEBUGVER_NONSTD        = 15 // debug not conforming to RISC-V debug spec
}